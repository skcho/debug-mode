Tutorial
========

We explain how to use the library in a gradual order from easy cases
to complicated ones.

NOTE: for simplicity, we use a module alias of the `Debugmode` module.

```ocaml
module DM = Debugmode
```

String query
------------

*Query* is the unit to traverse in the debug mode.  We will see
several kinds of queries in the tutorial.

Suppose the data we want to traverse is simply a string.

```ocaml
let name = "Alice"

let query = DM.short name
let _ = DM.run query
```

A string query is defined by `DM.short`.  Then, it runs the query by
applying `DM.run`.  Let's see what happens when running the above
code.

```
STACK empty
Alice

$
```

* `STACK` represents queries that have traversed up to now.  It is
  similar to the notion of directory tree, i.e., the empty `STACK`
  corresponds to the root directory `/`.

* `Alice` is the string data we wanted.

* `$` is a prompt of the debug shell.  We input some commands here,
  but for now the exit command is the only command available because
  we have not defined any commands yet.

This example is not that interesting.  Let's exit by entering `^`.

Option query
------------

Let's see more complicated cases.  Suppose we want to traverse
multiple data.

```ocaml
type t =
  { name : string
  ; hobby : string }

let gen_query d =
  DM.empty
  |> DM.add "name" (fun _ -> DM.short d.name)
  |> DM.add "hobby" (fun _ -> DM.short d.hobby)
  |> DM.final

let data =
  { name = "Alice"
  ; hobby = "programming" }

let _ = DM.run (gen_query data)
```

Let's see what happens when running the code, first.

```
STACK empty
  0 : name
  1 : hobby

$
```

It prints two available options the names of which are `name` and
`hobby` and commands to select one of them are `0` and `1`,
respectively.  Let's try entering the command `1`.

```
STACK > hobby
programming
```

It prints `programming` with the pushed stack, `STACK > hobby`.
What's going on here?

```ocaml
let gen_query d =
  DM.empty
  |> DM.add "name" (fun _ -> DM.short d.name)
  |> DM.add "hobby" (fun _ -> DM.short d.hobby)
  |> DM.final
```

We defined a function, `gen_query`, that generates a query that
contains some options to traverse.

* `DM.empty` is the empty set of options.

* `DM.add n f` adds an option, the name of which is `n` and the next
  query to traverse is generated by the `f` function.  For example,

  ```ocaml
  DM.add "hobby" (fun _ -> DM.short d.hobby)
  ```

  adds an option with the name `"hobby"`, and if the option is
  selected, `DM.short d.hobby` is traversed as the next query.

* `DM.final` finalizes the set of options and makes a query.

To conclude, we added two options to print each fields of the record
and `DM.run` started an interactive shell for us to select one of the
options.

If we enter `^`, it pops the `STACK`, so it goes back to the previous
state.  So, in this example, entering of the pop command `^` one time
brings us to the state before the `1` command is entered, and one more
pop command terminates the debug mode.

### TIP: string command

By default, commands are assigned as natural numbers from zero,
automatically.  On the other hand, we can specify string commands
using the parentheses, `[` and `]`, in option names, as follows.

```ocaml
let gen_query d =
  DM.empty
  |> DM.add "[n]ame" (fun _ -> DM.short d.name)
  |> DM.add "[h]obby" (fun _ -> DM.short d.hobby)
  |> DM.final
```

```
STACK empty
  h : hobby
  n : name
```

### TIP: quick exit

The pop command, `^`, can be used to pop multiple queries from the
`STACK`.  For example, `^^` pops two times and `^^^` pops three times.
Therefore, a long enough `^`s terminates the debug mode immediately.

Long string query
-----------------

Sometimes we may want to print a multi-lined very long data, however
it is not a good idea to use `DM.short` for that, because it requires
a composition of a long string value, which can be inefficient.  Use
`DM.long` instead, the argument of which is a function that prints the
long data by itself.

```ocaml
let print_long_msg () =
  prerr_endline "This is very long message.";
  prerr_endline "Isn't it? :P"

let query = DM.long print_long_msg
let _ = DM.run query
```

The result is,

```
STACK empty
This is very long message.
Isn't it? :P
```

### TIP: side effect

We can use the long string query to raise some side effects, e.g.,
writing some data to a file.

Option query with arguments
---------------------------

```ocaml
DM.add "[n]ame" (fun _ -> DM.short d.name)
```

Do you remember that the second argument of `DM.add` is a function?
Actually, the function gets some arguments that is a string list of
additional words following the command.  For example, if an option is
add by,

```ocaml
DM.add "[n]ame" gen_query_f
```

and some arguments are given with the `n` command as follows,

```
$ n arg1 arg2
```

it generates the next query by running `gen_query_f ["arg1"; "arg2"]`.

Others we better to know
------------------------

* The debug mode prints messages to the standard error output,
  `stderr`.

* Most words starting with alphabet can be used for the string
  command.  Just be careful not to use the characters, `[`, `]`, and
  spaces, for a string command.
